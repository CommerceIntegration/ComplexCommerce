<#
//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//    This code is licensed under the Microsoft Public License.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
// Parts of this code written by Rab Hallett. Some of it
// taken from the Microsoft ADO.NET C# POCO Generator.
// http://blogofrab.blogspot.com
//*********************************************************
#>
<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#

// --------------------------------------------------------------
// Change this line to your EDMX file if you used Add -> New Item
const string inputFile = @"ComplexCommerce.edmx";
// --------------------------------------------------------------

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataTools ef = new MetadataTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this);
EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

EdmItemCollection ItemCollection = null;
if ( inputFile == "$edmxInputFile" + "$" )
{
	fileManager.Process();
	return "#error The T4 generation file was added to the project by using Add -> New Item, "
		+ "but the inputFile string was not changed to the name of the EDMX file. "
		+ "Open the \".tt\" file, and change the value of \"inputFile\". Use \"Add Code "
		+ "Generation Item\" in the EDMX context menu to avoid this error in future.";
}
else
{
	ItemCollection = loader.CreateEdmItemCollection(inputFile);
}
string namespaceName = code.VsNamespaceSuggestion();

EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
if (container == null)
{
    return "// No EntityContainer exists in the model, so no code was generated";
}

WriteHeader();
WriteHeaderIncludeSystem();
WriteHeaderIncludeData();
WriteNamespaceBegin( code, namespaceName );
WriteQueryableExtension();
WriteNamespaceEnd( namespaceName );

fileManager.StartNewFile( "I" + container.Name + ".cs");

WriteHeader();
WriteHeaderIncludeSystem();
WriteHeaderIncludeData();
WriteNamespaceBegin( code, namespaceName );
WriteInterface( container, code );
WriteNamespaceEnd( namespaceName );


fileManager.StartNewFile( "IObjectContext.cs");

WriteHeader();
WriteHeaderIncludeSystem();
WriteHeaderIncludeData();
WriteHeaderIncludeContainers();
WriteNamespaceBegin( code, namespaceName );
WriteObjectContextInterface( container, code );
WriteNamespaceEnd( namespaceName );


fileManager.StartNewFile( container.Name + ".cs");
WriteHeader();
WriteHeaderIncludeData();
WriteNamespaceBegin( code, namespaceName );
WriteConcreteContextBody( container, code, ef, region );
WriteNamespaceEnd( namespaceName );

fileManager.StartNewFile( container.Name + "Mock.cs");
WriteHeader();
WriteHeaderIncludeData();
WriteAdditionalUsings( code, new string[] { namespaceName + "." + container + "MockObjectSet" } );
WriteNamespaceBegin( code, namespaceName );
WriteMockContextBody( container, code );
WriteNamespaceEnd( namespaceName );

fileManager.StartNewFile( container.Name + "Mock.ObjectContext.cs");
WriteHeader();
WriteHeaderIncludeSystem();
WriteHeaderIncludeData();
WriteHeaderIncludeContainers();
//WriteAdditionalUsings( code, new string[] { namespaceName + "." + container + "MockObjectSet" } );
WriteNamespaceBegin( code, namespaceName );
WriteObjectContextMockBase( container, code );
WriteNamespaceEnd( namespaceName );

fileManager.StartNewFile( container.Name + "Mock.ObjectSet.cs");
WriteHeader();
WriteHeaderIncludeSystem();
WriteHeaderIncludeContainers();
WriteHeaderIncludeData();
WriteNamespaceBegin( code, namespaceName + "." + container + "MockObjectSet" );
WriteMockObjectSet();
WriteNamespaceEnd( namespaceName );

fileManager.Process();
#>


<#+
void WriteInterface( EntityContainer container, CodeGenerationTools code )
{
#>
/// <summary>
/// The interface for the specialised object context. This contains all of
/// the <code>ObjectSet</code> properties that are implemented in both the
/// functional context class and the mock context class.
/// </summary>
<#=Accessibility.ForType(container)#> interface I<#=code.Escape(container)#> : IObjectContext
{
<#+
    foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
    {
#>
    IObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.Escape(entitySet)#> { get; }
<#+
    }
#>
}
<#+
}
#>


<#+
void WriteObjectContextInterface( EntityContainer container, CodeGenerationTools code )
{
#>
/// <summary>
/// The interface for the generic object context. This contains all of
/// the <code>ObjectContext</code> properties that are implemented in the 
/// concrete ObjectContext class. This interface was created so these members
/// can be mocked, as ObjectContext doesn't have a default public constructor.
/// </summary>
<#=Accessibility.ForType(container)#> interface IObjectContext : IDisposable
{
    void AcceptAllChanges();
    void AddObject(string entitySetName, object entity);
    TEntity ApplyCurrentValues<TEntity>(string entitySetName, TEntity currentEntity) where TEntity : class;
    TEntity ApplyOriginalValues<TEntity>(string entitySetName, TEntity originalEntity) where TEntity : class;
    void ApplyPropertyChanges(string entitySetName, object changed);
    void Attach(System.Data.Objects.DataClasses.IEntityWithKey entity);
    void AttachTo(string entitySetName, object entity);
    int? CommandTimeout { get; set; }
    DbConnection Connection { get; }
    ObjectContextOptions ContextOptions { get; }
    void CreateDatabase();
    string CreateDatabaseScript();
    EntityKey CreateEntityKey(string entitySetName, object entity);
    T CreateObject<T>() where T : class;
    ObjectSet<TEntity> CreateObjectSet<TEntity>() where TEntity : class;
    ObjectSet<TEntity> CreateObjectSet<TEntity>(string entitySetName) where TEntity : class;
    void CreateProxyTypes(IEnumerable<Type> types);
    ObjectQuery<T> CreateQuery<T>(string queryString, params ObjectParameter[] parameters);
    bool DatabaseExists();
    string DefaultContainerName { get; set; }
    void DeleteDatabase();
    void DeleteObject(object entity);
    void Detach(object entity);
    void DetectChanges();
    void Dispose();
    int ExecuteFunction(string functionName, params ObjectParameter[] parameters);
    ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, params ObjectParameter[] parameters);
    ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, MergeOption mergeOption, params ObjectParameter[] parameters);
    int ExecuteStoreCommand(string commandText, params object[] parameters);
    ObjectResult<TElement> ExecuteStoreQuery<TElement>(string commandText, params object[] parameters);
    ObjectResult<TEntity> ExecuteStoreQuery<TEntity>(string commandText, string entitySetName, MergeOption mergeOption, params object[] parameters);
    object GetObjectByKey(System.Data.EntityKey key);
    void LoadProperty(object entity, string navigationProperty);
    void LoadProperty(object entity, string navigationProperty, MergeOption mergeOption);
    void LoadProperty<TEntity>(TEntity entity, Expression<Func<TEntity, object>> selector);
    void LoadProperty<TEntity>(TEntity entity, Expression<Func<TEntity, object>> selector, MergeOption mergeOption);
    System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }
    ObjectStateManager ObjectStateManager { get; }
    void Refresh(RefreshMode refreshMode, IEnumerable collection);
    void Refresh(RefreshMode refreshMode, object entity);
    int SaveChanges();
    int SaveChanges(bool acceptChangesDuringSave);
    int SaveChanges(SaveOptions options);
    ObjectResult<TElement> Translate<TElement>(DbDataReader reader);
    ObjectResult<TEntity> Translate<TEntity>(DbDataReader reader, string entitySetName, MergeOption mergeOption);
    bool TryGetObjectByKey(EntityKey key, out object value);
}
<#+
}
#>

<#+
void WriteObjectContextMockBase( EntityContainer container, CodeGenerationTools code )
{
#>
/// <summary>
/// The default concrete implementation of IObjectContext that will be used for mocking. 
/// This contains all of the <code>IObjectContext</code> members that are implemented in the 
/// concrete ObjectContext class. This class was created so these members
/// can be mocked.
/// </summary>
//<#=Accessibility.ForType(container)#> partial class <#=code.Escape(container)#>Mock : IObjectContext
<#=Accessibility.ForType(container)#> abstract class ObjectContextMockBase : IObjectContext
{
    private readonly IObjectContext _objectContext;
    public ObjectContextMockBase(IObjectContext objectContext)
    {
        if (objectContext == null)
            throw new System.ArgumentNullException("objectContext");
        _objectContext = objectContext;
    }

    public virtual void AcceptAllChanges()
    {
        _objectContext.AcceptAllChanges();
    }
    
    public virtual void AddObject(string entitySetName, object entity)
    {
        _objectContext.AddObject(entitySetName, entity);
    }
    
    public virtual TEntity ApplyCurrentValues<TEntity>(string entitySetName, TEntity currentEntity) 
    	where TEntity : class
    {
        return _objectContext.ApplyCurrentValues<TEntity>(entitySetName, currentEntity);
    }
    
    public virtual TEntity ApplyOriginalValues<TEntity>(string entitySetName, TEntity originalEntity) 
    	where TEntity : class
    {
    	return ApplyOriginalValues<TEntity>(entitySetName, originalEntity);
    }
    
    public virtual void ApplyPropertyChanges(string entitySetName, object changed)
    {
        _objectContext.ApplyPropertyChanges(entitySetName, changed);
    }
    
    public virtual void Attach(System.Data.Objects.DataClasses.IEntityWithKey entity)
    {
        _objectContext.Attach(entity);
    }
    
    public virtual void AttachTo(string entitySetName, object entity)
    {
        _objectContext.AttachTo(entitySetName, entity);
    }
    
    public virtual int? CommandTimeout
    {
        get { return _objectContext.CommandTimeout; }
        set { _objectContext.CommandTimeout = value; }
    }
    
    public virtual DbConnection Connection 
    { 
    	get { return _objectContext.Connection; }
    }
    
    public virtual ObjectContextOptions ContextOptions
    { 
    	get { return _objectContext.ContextOptions; }
    }
    
    public virtual void CreateDatabase()
    {
        _objectContext.CreateDatabase();
    }
    
    public virtual string CreateDatabaseScript()
    {
    	return _objectContext.CreateDatabaseScript();
    }
    
    public virtual EntityKey CreateEntityKey(string entitySetName, object entity)
    {
    	return _objectContext.CreateEntityKey(entitySetName, entity);
    }
    
    public virtual T CreateObject<T>() 
    	where T : class
    {
    	return _objectContext.CreateObject<T>();
    }
    
    public virtual ObjectSet<TEntity> CreateObjectSet<TEntity>()
    	where TEntity : class
    {
    	return _objectContext.CreateObjectSet<TEntity>();
    }
    
    public virtual ObjectSet<TEntity> CreateObjectSet<TEntity>(string entitySetName) 
    	where TEntity : class
    {
    	return _objectContext.CreateObjectSet<TEntity>(entitySetName);
    }
    
    public virtual void CreateProxyTypes(IEnumerable<Type> types)
    {
        _objectContext.CreateProxyTypes(types);
    }
    
    public virtual ObjectQuery<T> CreateQuery<T>(string queryString, params ObjectParameter[] parameters)
    {
    	return _objectContext.CreateQuery<T>(queryString, parameters);
    }
    
    public virtual bool DatabaseExists()
    {
    	return _objectContext.DatabaseExists();
    }
    
    public virtual string DefaultContainerName
    {
        get { return _objectContext.DefaultContainerName; }
        set { _objectContext.DefaultContainerName = value; }
    }
    
    public virtual void DeleteDatabase()
    {
        _objectContext.DeleteDatabase();
    }
    
    public virtual void DeleteObject(object entity)
    {
        _objectContext.DeleteObject(entity);
    }
    
    public virtual void Detach(object entity)
    {
        _objectContext.Detach(entity);
    }
    
    public virtual void DetectChanges()
    {
        _objectContext.DetectChanges();
    }
    
    public virtual void Dispose()
    {
        _objectContext.Dispose();
    }
    
    public virtual int ExecuteFunction(string functionName, params ObjectParameter[] parameters)
    {
        return _objectContext.ExecuteFunction(functionName, parameters);
    }
    
    public virtual ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, params ObjectParameter[] parameters)
    {
    	return _objectContext.ExecuteFunction<TElement>(functionName, parameters);
    }
    
    public virtual ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, MergeOption mergeOption, params ObjectParameter[] parameters)
    {
    	return _objectContext.ExecuteFunction<TElement>(functionName, mergeOption, parameters);
    }
    
    public virtual int ExecuteStoreCommand(string commandText, params object[] parameters)
    {
        return _objectContext.ExecuteStoreCommand(commandText, parameters);
    }
    
    public virtual ObjectResult<TElement> ExecuteStoreQuery<TElement>(string commandText, params object[] parameters)
    {
    	return _objectContext.ExecuteStoreQuery<TElement>(commandText, parameters);
    }
    
    public virtual ObjectResult<TEntity> ExecuteStoreQuery<TEntity>(string commandText, string entitySetName, MergeOption mergeOption, params object[] parameters)
    {
    	return _objectContext.ExecuteStoreQuery<TEntity>(commandText, entitySetName, mergeOption, parameters);
    }
    
    public virtual object GetObjectByKey(EntityKey key)
    {
    	return _objectContext.GetObjectByKey(key);
    }
    
    public virtual void LoadProperty(object entity, string navigationProperty)
    {
        _objectContext.LoadProperty(entity, navigationProperty);
    }
    
    public virtual void LoadProperty(object entity, string navigationProperty, MergeOption mergeOption)
    {
        _objectContext.LoadProperty(entity, navigationProperty, mergeOption);
    }
    
    public virtual void LoadProperty<TEntity>(TEntity entity, Expression<Func<TEntity, object>> selector)
    {
        _objectContext.LoadProperty<TEntity>(entity, selector);
    }
    
    public virtual void LoadProperty<TEntity>(TEntity entity, Expression<Func<TEntity, object>> selector, MergeOption mergeOption)
    {
        _objectContext.LoadProperty<TEntity>(entity, selector, mergeOption);
    }
    
    public virtual System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace
    {
    	get { return _objectContext.MetadataWorkspace; }
    }
    
    public virtual ObjectStateManager ObjectStateManager
    {
    	get { return _objectContext.ObjectStateManager; }
    }
    
    public virtual void Refresh(RefreshMode refreshMode, IEnumerable collection)
    {
        _objectContext.Refresh(refreshMode, collection);
    }
    
    public virtual void Refresh(RefreshMode refreshMode, object entity)
    {
        _objectContext.Refresh(refreshMode, entity);
    }
    
    public virtual int SaveChanges()
    {
    	return _objectContext.SaveChanges();
    }
    
    public virtual int SaveChanges(bool acceptChangesDuringSave)
    {
    	return _objectContext.SaveChanges(acceptChangesDuringSave);
    }
    
    public virtual int SaveChanges(SaveOptions options)
    {
    	return _objectContext.SaveChanges(options);
    }
    
    public virtual ObjectResult<TElement> Translate<TElement>(DbDataReader reader)
    {
    	return _objectContext.Translate<TElement>(reader);
    }
    
    public virtual ObjectResult<TEntity> Translate<TEntity>(DbDataReader reader, string entitySetName, MergeOption mergeOption)
    {
    	return _objectContext.Translate<TEntity>(reader, entitySetName, mergeOption);
    }
    
    public virtual bool TryGetObjectByKey(EntityKey key, out object value)
    {
        return _objectContext.TryGetObjectByKey(key, out value);
    }
}
<#+
}
#>




<#+
void WriteMockContextBody( EntityContainer container, CodeGenerationTools code )
{
#>
/// <summary>
/// The concrete mock context object that implements the context's interface.
/// Provide an instance of this mock context class to client logic when testing, 
/// instead of providing a functional context object.
/// </summary>
<#=Accessibility.ForType(container)#> partial class <#=code.Escape(container)#>Mock : ObjectContextMockBase, I<#=code.Escape(container)#>
{
	public <#=code.Escape(container)#>Mock(IObjectContext objectContext)
        : base(objectContext)
    {
    }
<#+
        foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
#>
    <#=Accessibility.ForReadOnlyProperty(entitySet)#> virtual IObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.Escape(entitySet)#>
    {
        get { return <#=code.FieldName(entitySet) #>  ?? (<#=code.FieldName(entitySet)#> = new MockObjectSet<<#=code.Escape(entitySet.ElementType)#>>()); }
    }
    private IObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.FieldName(entitySet)#>;
<#+
        }
#>
}
<#+
}
#>


<#+
void WriteConcreteContextBody( EntityContainer container, CodeGenerationTools code, MetadataTools ef, CodeRegion region )
{

#>
/// <summary>
/// The functional concrete object context. This is just like the normal
/// context that would be generated using the POCO artefact generator, 
/// apart from the fact that this one implements an interface containing 
/// the entity set properties and exposes <code>IObjectSet</code>
/// instances for entity set properties.
/// </summary>
<#=Accessibility.ForType(container)#> partial class <#=code.Escape(container)#> : ObjectContext, I<#=code.Escape(container)#> 
{
    public const string ConnectionString = "name=<#=container.Name#>";
    public const string ContainerName = "<#=container.Name#>";

    #region Constructors

    public <#=code.Escape(container)#>():
        base(ConnectionString, ContainerName)
    {
<#+
        WriteLazyLoadingEnabled(container);
#>
    }

    public <#=code.Escape(container)#>(string connectionString):
        base(connectionString, ContainerName)
    {
<#+
        WriteLazyLoadingEnabled(container);
#>
    }

    public <#=code.Escape(container)#>(EntityConnection connection):
        base(connection, ContainerName)
    {
<#+
        WriteLazyLoadingEnabled(container);
#>
    }

    #endregion

<#+
        region.Begin("ObjectSet Properties", 2);

        foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
#>

    <#=Accessibility.ForReadOnlyProperty(entitySet)#> IObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.Escape(entitySet)#>
    {
        get { return <#=code.FieldName(entitySet) #> ?? (<#=code.FieldName(entitySet)#> = CreateObjectSet<<#=code.Escape(entitySet.ElementType)#>>("<#=entitySet.Name#>")); }
    }
    private ObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.FieldName(entitySet)#>;
<#+
        }

        region.End();

        region.Begin("Function Imports");

        foreach (EdmFunction edmFunction in container.FunctionImports)
        {
            var parameters = FunctionImportParameter.Create(edmFunction.Parameters, code, ef);
            string paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
            if (edmFunction.ReturnParameter == null)
            {
                continue;
            }
            string returnTypeElement = code.Escape(ef.GetElementType(edmFunction.ReturnParameter.TypeUsage));

#>
    <#=Accessibility.ForMethod(edmFunction)#> ObjectResult<<#=returnTypeElement#>> <#=code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#+
            foreach (var parameter in parameters)
            {
                if (!parameter.NeedsLocalVariable)
                {
                    continue;
                }
#>

        ObjectParameter <#=parameter.LocalVariableName#>;

        if (<#=parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#+
            }
#>
        return base.ExecuteFunction<<#=returnTypeElement#>>("<#=edmFunction.Name#>"<#=code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()))#>);
    }
<#+
		}

        region.End();
#>
}
<#+
}
#>

<#+
void WriteMockObjectSet()
{
#>
/// <summary>
/// Concrete object set for use with Mock contexts. Implements all of the
/// required interfaces, but performs no database functionality; instead
/// merely stores the data for testing.
/// </summary>
public partial class MockObjectSet<T> : IObjectSet <T> 
    where T : class
{
    private readonly IList<T> m_container = new List<T>();

    #region IObjectSet<T> Members
    /// <summary>
    /// Notifies the set that an object that represents a new entity must 
    /// be added to the set.
    /// </summary>
    public void AddObject(T entity)
    {
        m_container.Add(entity);
    }

    /// <summary>
    /// Notifies the set that an object that represents an existing entity
    /// must be added to the set.
    /// </summary>
    public void Attach(T entity)
    {
        m_container.Add(entity);
    }

    /// <summary>
    /// Notifies the set that an object that represents an existing entity 
    /// must be deleted from the set.
    /// </summary>
    public void DeleteObject(T entity)
    {
        m_container.Remove(entity);
    }

    /// <summary>
    /// Notifies the set that an object that represents an existing entity must be
    /// detached from the set.
    /// </summary>
    /// <param name="entity"></param>
    public void Detach(T entity)
    {
        m_container.Remove(entity);
    }
    #endregion

    #region IEnumerable<T> Members
    /// <summary>
    /// Returns an enumerator that iterates through the collection.
    /// </summary>
    public IEnumerator<T> GetEnumerator()
    {
        return m_container.GetEnumerator();
    }
    #endregion

    #region IEnumerable Members
    /// <summary>
    /// Returns an enumerator that iterates through the collection.
    /// </summary>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return m_container.GetEnumerator();
    }
    #endregion

    #region IQueryable<T> Members
    /// <summary>
    /// Gets the type of the element(s) that are returned when the expression 
    /// tree associated with this instance of System.Linq.IQueryable is executed.
    /// </summary>
    public Type ElementType
    {
        get { return typeof(T); }
    }

    /// <summary>
    /// Gets the expression tree that is associated with the instance of 
    /// <code>System.Linq.IQueryable.</code>
    /// </summary>
    public System.Linq.Expressions.Expression Expression
    {
        get { return m_container.AsQueryable<T>().Expression; }
    }

    /// <summary>
    /// Gets the query provider that is associated with this data source.
    /// </summary>
    public IQueryProvider Provider
    {
        get { return m_container.AsQueryable<T>().Provider; }
    }
    #endregion
}
<#+
}
#>

<#+
private void WriteLazyLoadingEnabled(EntityContainer container)
{
   string lazyLoadingAttributeValue = null;
   string lazyLoadingAttributeName = MetadataConstants.EDM_ANNOTATION_09_02 + ":LazyLoadingEnabled";
   if(MetadataTools.TryGetStringMetadataPropertySetting(container, lazyLoadingAttributeName, out lazyLoadingAttributeValue))
   {
       bool isLazyLoading = false;
       if(bool.TryParse(lazyLoadingAttributeValue, out isLazyLoading))
       {
#>
        this.ContextOptions.LazyLoadingEnabled = <#=isLazyLoading.ToString().ToLowerInvariant()#>;
<#+
       }
   }
}
#>

<#+
void WriteHeader()
{
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Architectural overview and usage guide: 
// http://blogofrab.blogspot.com/2010/08/maintenance-free-mocking-for-unit.html
//------------------------------------------------------------------------------
<#+
}
#>

<#+
void WriteHeaderIncludeSystem()
{
#>
using System;
using System.Linq;
using System.Linq.Expressions;
<#+
}
#>

<#+
void WriteHeaderIncludeContainers()
{
#>
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
<#+
}
#>

<#+
void WriteHeaderIncludeData()
{
#>
using System.Data;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Data.Common;
<#+
}
#>

<#+
void WriteAdditionalUsings( CodeGenerationTools code, string[] additionalUsings )
{
	if ( additionalUsings != null )
	{
		foreach( string additionalUsing in additionalUsings )
		{
#>
using <#=code.EscapeNamespace(additionalUsing)#>;
<#+
		}
	}
}
#>

<#+
void WriteQueryableExtension()
{
#>
/// <summary>
/// Additional extension for interface <code>IQueryableExtension</code>, to
/// allow includes on <code>IObjectSet</code> when using mocking contexts.
/// </summary>
public static class IQueryableExtension
{
    public static IQueryable<T> Include<T>
        (this IQueryable<T> source, string path)
        where T : class
    {
        ObjectQuery<T> objectQuery = source as ObjectQuery<T>;
        if (objectQuery != null)
        {
            return objectQuery.Include(path);
        }
        return source;
    }
}
<#+
}
#>

<#+
void WriteNamespaceBegin( CodeGenerationTools code, string namespaceName )
{
	if (!String.IsNullOrEmpty(namespaceName))
	{
#>

namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
		PushIndent(CodeRegion.GetIndent(1));
	}
}
#>

<#+
void WriteNamespaceEnd( string namespaceName )
{
	if (!String.IsNullOrEmpty(namespaceName))
	{
		PopIndent();
#>
}
<#+
	}
}
#>
